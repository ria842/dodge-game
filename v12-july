<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Dodge Game (Enhanced)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #111;
      }
      #info,
      #scoreDisplay {
        position: absolute;
        left: 10px;
        font-family: monospace;
        z-index: 2;
      }
      #info {
        top: 10px;
        color: #0ff;
      }
      #scoreDisplay {
        top: 40px;
        color: #0f0;
        font-size: 16px;
      }
      #restartBtn {
        position: absolute;
        top: 70px;
        left: 10px;
        font-size: 16px;
        padding: 5px 10px;
        z-index: 1;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="info">
      Use ← → to move, Space to jump, Ctrl to crouch. Dodge the balls!
    </div>
    <div id="scoreDisplay">Score: 0 | High Score: 0</div>
    <button id="restartBtn" onclick="window.location.reload()">Restart</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1.1);
      light.position.set(5, 10, 7.5);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x555555));

      const ground = new THREE.Mesh(
        new THREE.BoxGeometry(10, 1, 40),
        new THREE.MeshPhongMaterial({ color: 0x333333 })
      );
      ground.position.y = -0.5;
      scene.add(ground);

      const player = new THREE.Group();
      const torso = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16),
        new THREE.MeshPhongMaterial({ color: 0x2196f3 })
      );
      torso.position.y = 1.1;
      player.add(torso);
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 16, 16),
        new THREE.MeshPhongMaterial({ color: 0xffe0b2 })
      );
      head.position.y = 1.9;
      player.add(head);
      const legL = new THREE.Mesh(
        new THREE.CylinderGeometry(0.18, 0.18, 0.9, 12),
        new THREE.MeshPhongMaterial({ color: 0x795548 })
      );
      legL.position.set(-0.22, 0.45, 0);
      player.add(legL);
      const legR = legL.clone();
      legR.position.x = 0.22;
      player.add(legR);
      const armL = new THREE.Mesh(
        new THREE.CylinderGeometry(0.13, 0.13, 0.9, 12),
        new THREE.MeshPhongMaterial({ color: 0x2196f3 })
      );
      armL.position.set(-0.68, 1.3, 0);
      armL.rotation.z = Math.PI / 8;
      player.add(armL);
      const armR = armL.clone();
      armR.position.x = 0.68;
      armR.rotation.z = -Math.PI / 8;
      player.add(armR);
      scene.add(player);
      player.position.y = 0.9;

      let moveLeft = false,
        moveRight = false,
        jumping = false,
        crouching = false;
      let velocityY = 0;
      const gravity = -0.08,
        jumpStrength = 0.4;
      let projectiles = [],
        spawnTimer = 0;
      const projectileHeights = [0.4, 1.2, 2.3];

      function spawnProjectile() {
        const radius = 0.3 + Math.random() * 0.5;
        const geometry = new THREE.SphereGeometry(radius, 18, 18);
        const color = new THREE.Color(`hsl(${Math.random() * 360}, 100%, 50%)`);
        const proj = new THREE.Mesh(
          geometry,
          new THREE.MeshPhongMaterial({ color })
        );
        proj.position.set(
          (Math.random() - 0.5) * 8,
          projectileHeights[
            Math.floor(Math.random() * projectileHeights.length)
          ],
          -18
        );
        proj.userData.speed = 0.25 + Math.random() * 0.1;
        scene.add(proj);
        projectiles.push(proj);
      }

      camera.position.set(0, 5, 10);
      camera.lookAt(0, 1, 0);

      window.addEventListener("keydown", (e) => {
        if (e.code === "ArrowLeft") moveLeft = true;
        if (e.code === "ArrowRight") moveRight = true;
        if (e.code === "Space" && !jumping && !crouching) {
          velocityY = jumpStrength;
          jumping = true;
        }
        if (e.code.startsWith("Control")) crouching = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "ArrowLeft") moveLeft = false;
        if (e.code === "ArrowRight") moveRight = false;
        if (e.code.startsWith("Control")) crouching = false;
      });

      // Touch and Mouse Controls
      window.addEventListener("touchstart", (e) => {
        const x = e.touches[0].clientX;
        if (x < window.innerWidth / 2) moveLeft = true;
        else moveRight = true;
      });
      window.addEventListener("touchend", () => {
        moveLeft = false;
        moveRight = false;
      });
      window.addEventListener("mousedown", (e) => {
        if (e.clientX < window.innerWidth / 2) moveLeft = true;
        else moveRight = true;
      });
      window.addEventListener("mouseup", () => {
        moveLeft = false;
        moveRight = false;
      });

      function checkCollision(a, b) {
        return new THREE.Box3()
          .setFromObject(a)
          .intersectsBox(new THREE.Box3().setFromObject(b));
      }

      let score = 0;
      let highScore = parseInt(localStorage.getItem("highScore") || "0");
      document.getElementById(
        "scoreDisplay"
      ).innerText = `Score: 0 | High Score: ${highScore}`;
      setInterval(() => {
        if (!gameOver) {
          score++;
          document.getElementById(
            "scoreDisplay"
          ).innerText = `Score: ${score} | High Score: ${highScore}`;
        }
      }, 1000);

      let gameOver = false;
      function animate() {
        if (gameOver) return;
        requestAnimationFrame(animate);

        if (moveLeft && player.position.x > -4) player.position.x -= 0.15;
        if (moveRight && player.position.x < 4) player.position.x += 0.15;

        if (jumping) {
          player.position.y += velocityY;
          velocityY += gravity;
          if (player.position.y <= 0.9) {
            player.position.y = 0.9;
            jumping = false;
            velocityY = 0;
          }
        }

        if (crouching && !jumping) {
          player.scale.y = 0.6;
          player.position.y = 0.5;
        } else if (!jumping) {
          player.scale.y = 1;
          player.position.y = 0.9;
        }

        camera.position.x += (player.position.x - camera.position.x) * 0.1;
        camera.lookAt(player.position.x, 1, 0);

        spawnTimer++;
        if (spawnTimer > 40) {
          spawnProjectile();
          spawnTimer = 0;
        }

        for (let i = projectiles.length - 1; i >= 0; i--) {
          const proj = projectiles[i];
          proj.position.z += proj.userData.speed;
          if (proj.position.z > 10) {
            scene.remove(proj);
            projectiles.splice(i, 1);
          } else if (checkCollision(player, proj)) {
            document.getElementById("info").innerText = "Game Over!";
            gameOver = true;
            if (score > highScore) {
              highScore = score;
              localStorage.setItem("highScore", highScore);
            }
            document.getElementById(
              "scoreDisplay"
            ).innerText = `Score: ${score} | High Score: ${highScore}`;
            document.getElementById("restartBtn").style.display = "block";
            return;
          }
        }

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
